(*
  MTProto 2.0: Rekeying

  Model for the protocol used for updating the session keys of secret
  chats.

  See: https://core.telegram.org/api/end-to-end/pfs

  Run with:

      proverif -lib mtproto2 mtproto2-reky-secr.pv
*)

query attacker(secretMsg).
(* ✔︎ Result: true *)


const IR: Principal. (* Initiator *)
const RR: Principal. (* Responder *)

(*
  As in secret chats, the server is considered untrusted. As the
  server acts only as a forwarder, instead of modeling the server's
  process explicitly, we equip the adversary with the same knowledge
  as the server (the authorization keys, which are implicitly known
  to the adversary as we do not use them in this model), and let the
  adversary do the forwarding.
*)
process
  (*
    The current secret key shared by the clients, which, we assume, has been
    created correctly (i.e., by performing all the necessary checks; see secret
    chat protocol) during the first secret chat session.

   Note that, if the DH parameters are weak (see commented lines
   below) then ProVerif can prove that secrecy fails.
  *)
  new k: SharedKey;
  (0
  | !RekeyingInitiator(IR, k, STRONG_DH, G, RR)
  | !RekeyingResponder(RR, k, STRONG_DH, G, IR)
  (* | !RekeyingInitiator(IR, k, WEAK_DH, G, RR) *)
  (* | !RekeyingResponder(RR, k, WEAK_DH, G, IR) *)
  (* | !RekeyingInitiator(IR, k, STRONG_DH, BAD_ELEM, RR) *)
  (* | !RekeyingResponder(RR, k, STRONG_DH, BAD_ELEM, IR) *)
  )
