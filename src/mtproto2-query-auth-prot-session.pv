(*
 * MTProto 2.0: Creating an authorization key.
 *
 * Expected time to run this script: ~9min
 *)

set preciseActions = true.

(* Test for reachability. TODO: move to debug queries *)
(* query nc, nc', ns, ns', nk, nk': Nonce, p, p': Modulus, g, g', g_a, g_b: G, a, b: Z, k: AuthKey; *)
(*   event(ServerAcceptsAuthKey(nc, ns, nk, p, g, a, g_b, k)) && event(ClientAcceptsAuthKey(nc', ns', nk', p', g', g_a, b, k)). *)
(* ✖︎ Expected result: false *)

(*
 * If client and server end up accepting the same key, then they do so in the
 * same session, unless something bad happens.
 *)
query nc, nc', ns, ns', nk, nk': Nonce, p, p': Modulus, g, g', g_a, g_b: G, a, b: Z, k: AuthKey, sk: PrivKey;
  event(ClientAcceptsAuthKey(nc, ns, nk, p, g, g_a, b, k)) && event(ServerAcceptsAuthKey(nc', ns', nk', p', g', a, g_b, k))
  ==> (nc = nc' && ns = ns' && nk = nk')
  || event(ClientChecksDHParameters(nc, ns, nk, p, g, g_a, false))
  || event(RevealedRSAKey(sk))
  || event(RevealedNk(nk))
  || event(RevealedNk(nk')).
(* ✔︎ Expected result: true *)


(* Main *)
process
  let allowWeakDiffieHellman = true in
  (0
    | !RegisterRSAKey(Server)
    | !ServerAuth(Server)
    | !ClientAuth(Server, allowWeakDiffieHellman)

    (* Utility processes (serving ServerAuth()) *)
    | !GenGoodDHParameters()
    | !GenBadDHParameters()

    (* Allow the attacker to impersonate the server *)
    | !RevealRSAKey()

    (* Allow the attacker to learn any authorization key *)
    | !RevealAuthKey()

    (* Allow the attacker to reveal (part of) the client's ephemeral state *)
    | !RevealNk()
    | !RevealAuthProtClientExponent()

    (* Allow the attacker to reveal the server's ephemeral key (the DH exponent) *)
    | !RevealAuthProtServerExponent()
  )

