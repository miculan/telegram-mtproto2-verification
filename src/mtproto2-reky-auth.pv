(*
  MTProto 2.0: Rekeying

  Model for the protocol used for updating the session keys of secret
  chats.

  See: https://core.telegram.org/api/end-to-end/pfs

  Run with:

      proverif -lib mtproto2 mtproto2-reky-secr.pv
*)

query A: Principal, B: Principal, m: bitstring, k: SharedKey;
  inj-event(ResponderReceivesMsgWithNewKey(A, B, m, k))
    ==> inj-event(InitiatorSendsMsgWithNewKey(A, B, m, k)).
(* ✔︎ Result: true *)


const IR: Principal. (* Initiator *)
const RR: Principal. (* Responder *)

(*
  As in secret chats, the server is considered untrusted. As the
  server acts only as a forwarder, instead of modeling the server's
  process explicitly, we equip the adversary with the same knowledge
  as the server (the authorization keys, which are implicitly known
  to the adversary as we do not use them in this model), and let the
  adversary do the forwarding.
*)
process
  (*
    The current secret key shared by the clients, which, we assume, has been
    created correctly (i.e., by performing all the necessary checks; see secret
    chat protocol) during the first secret chat session.

    Note that if the clients have weak DH parameters (see commented lines
    below), e.g., because they skipped some check when their first shared key
    k was created, then authentication fails, i.e., RR may receive an encrypted
    message that was not sent by IR.
  *)
  new k: SharedKey;
  (0
  | !RekeyingInitiator(IR, k, STRONG_DH, G, RR)
  | !RekeyingResponder(RR, k, STRONG_DH, G, IR)
  (* | !RekeyingInitiator(IR, k, WEAK_DH, G, RR) *)
  (* | !RekeyingResponder(RR, k, WEAK_DH, G, IR) *)
  (* | !RekeyingInitiator(IR, k, STRONG_DH, BAD_ELEM, RR) *)
  (* | !RekeyingResponder(RR, k, STRONG_DH, BAD_ELEM, IR) *)
  )

