(*
 * MTProto 2.0: Secret Chats
 *
 * Model for the protocol used to in secret chats.
 *
 * See: https://core.telegram.org/api/end-to-end
 *
 * Expected time to run this script:
 *)

set preciseActions = true.

(*
 * If a client X (one of I or R) receives a message m encrypted with a session
 * key k in a chat session i initiated by I with responder R, then such message
 * was sent by client Y (one of I or R), unless they skip some mandatory check.
 *
 * NOTE: X and Y need not be distinct.
 *
 * NOTE: we cannot force i = i', because the chat session identifier is available to the
 * server/attacker, who is free to change it when forwarding messages.
 *
 * NOTE: the second disjunct corresponds to the following theoretical
 * cross-session attack. Let A and B be two honest clients, and let E be the
 * attacker. Then, the attack proceeds as follows:
 *
 * - A initiates a chat i  with B, sending half-key g^a;
 * - B initiates a chat i' with A, sending half-key g^b;
 * - E acts as a responder in both sessions, impersonating B to A and A to B; that is:
 * - E accepts a chat with B by sending (A,g^a) to B;
 * - E accepts a chat with A by sending (B,g^b) to A;
 * - A and B generate and (out-of-band) validate the session key g^ab;
 * - A (resp. B) sends a message m to B (resp. A) in session i;
 * - E redirects m to B (resp. A) in session i'.
 *
 * So, E is free to mix messages exhanged by A and B across different sessions.
 * This attack can be prevented by having A and B validate not only the session
 * key, but also the chat session identifier (see table QRTableExtended).
 *
 * NOTE: proving this requires preciseActions = true.
 *)
query i, i': ChatID, X,Y,I,R: Principal, k: SessionKey, m: bitstring, a,b: Z;
  event(ClientReceivesSecretChatMsg(i, X, I, R, k, m))
  ==> event(ClientSendsSecretChatMsg(i', Y, I, R, k, m))
  ||  event(ClientSendsSecretChatMsg(i', Y, R, I, k, m))
  || (event(OutOfBandKeyComparisonSkipped(a, X, k)) && event(OutOfBandKeyComparisonSkipped(b, Y, k)))
  || (event(ClientChecksDHConfig(a, i, X, false)) && event(ClientChecksDHConfig(b, i', Y, false))).
(* ✔︎ Expected result: true (~9min) *)

(*
 * If an (honest) initiator negotiates a key k to chat with Bob, and an
 * (honest) responder accepts a key k to chat with Alice, then the initiator is
 * Alice and the responder is Bob.
 *)
query i,i': ChatID, a,b: Z, I,R: Principal, k: SessionKey;
  event(InitiatorAcceptsEncryptedChat(a, i, I, Bob, k))
  && event(ResponderAcceptsEncryptedChat(b, i', Alice, R, k))
  ==> (I = Alice && R = Bob)
  || (event(OutOfBandKeyComparisonSkipped(a, I, k)) && event(OutOfBandKeyComparisonSkipped(b, R, k)))
  || (event(ClientChecksDHConfig(a, i, I, false)) && event(ClientChecksDHConfig(b, i', R, false))).
(* ✔︎ Expected result: true *)

(*
 * A variant of the above
 *)
query i,i': ChatID, a,b,x: Z, X,I,R: Principal, k: SessionKey;
  event(InitiatorAcceptsEncryptedChat(a, i, I, Bob, k))
  && event(ResponderAcceptsEncryptedChat(b, i', Alice, R, k))
  ==> (I = Alice && R = Bob)
  || event(OutOfBandKeyComparisonSkipped(x, X, k)).
(* ✔︎ Expected result: true *)

(*
 * More generally, if an (honest) initiator I negotiates a session key k to
 * chat with R, and an (honest) responder R' negotiates the same key k to chat
 * with I', then there are only two parties involved, unless the clients skip
 * the out-of-band validation of k.
 *)
query i,i': ChatID, a,b,x: Z, X,I,I',R,R': Principal, k: SessionKey;
  event(InitiatorAcceptsEncryptedChat(a, i, I, R, k))
  && event(ResponderAcceptsEncryptedChat(b, i', I', R', k))
  ==> (I = I' && R = R') || (I = R' && R = I')
  || event(OutOfBandKeyComparisonSkipped(x, X, k)).
(* ✔︎ Expected result: true *)

(*
 * If all clients validate their keys and check their DH parameters, then we
 * can prove something stronger: if an (honest) initiator I negotiates a
 * session key k to chat with R, and an (honest) responder R' negotiates the
 * same key k to chat with I', then there are only two parties involved, and in
 * particular I = I' and R = R'.
 *)
query i,i',j: ChatID, a,b,x: Z, X,I,I',R,R': Principal, k: SessionKey;
  event(InitiatorAcceptsEncryptedChat(a, i, I, R, k))
  && event(ResponderAcceptsEncryptedChat(b, i', I', R', k))
  ==> (I = I' && R = R')
  ||  event(OutOfBandKeyComparisonSkipped(x, X, k))
  ||  event(ClientChecksDHConfig(x, j, X, false)).
(* ✔︎ Expected result: true *)

(* A variant of the above *)
query i,i',j,j': ChatID, a,b,x,y: Z, X,I,I',R,R': Principal, k: SessionKey;
  event(InitiatorAcceptsEncryptedChat(a, i, I, R, k))
  && event(ResponderAcceptsEncryptedChat(b, i', I', R', k))
  ==> (I = I' && R = R')
  ||  event(OutOfBandKeyComparisonSkipped(y, R', k))
  || (event(ClientChecksDHConfig(x, j, I', false)) && event(ClientChecksDHConfig(y, j', R', false))).
(* ✔︎ Expected result: true *)

(*
 * If the clients do not necessarily validate their keys, then the above does
 * not hold. In fact, I, I', R, and R' may be all different (even if the key is
 * the same!).
 *)
query a,b,x: Z, i: ChatID, X,I,I',R,R': Principal, k: SessionKey;
  event(InitiatorAcceptsEncryptedChat(a, i, I, R, k))
  && event(ResponderAcceptsEncryptedChat(b, i, I', R', k))
  ==> I = I' || R = R' || I = R' || R = I'
  || event(ClientChecksDHConfig(x, i, X, false)).
(* ✖︎ Expected result: false *)


(* Main *)

let Init() =
  (*
   * Authorization keys are not used in our model of the secret chat protocol,
   * because we include the server in the attacker's model. The following,
   * however, is needed for the chat processes to proceed.
   *)
  new k1: AuthKey;
  new k2: AuthKey;
  insert AuthKeyClientTable(Alice, Server, k1);
  insert AuthKeyClientTable(Bob, Server, k2);
  0.

process
  let allowWeakDiffieHellman = true in
  (0
    | !Init()
    | !SecretChatInitiator(Server, allowWeakDiffieHellman)
    | !SecretChatResponder(Server, allowWeakDiffieHellman)
    | !PerformOutOfBandKeyComparison()
    | !SkipOutOfBandKeyComparison()
    | !SecretChatSend()
    | !SecretChatReceive()
  )

