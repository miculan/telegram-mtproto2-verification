(*
 * MTProto 2.0: Creating an authorization key.
 *
 * Model for the protocol used to create long-term keys shared between a client
 * and Telegram's server.
 *
 * See: https://core.telegram.org/mtproto/auth_key
 *)

(******************************************************************************)
(* "Abstract" cryptographic primitives                                        *)
(*                                                                            *)
(* NOTE: These MUST be defined somewhere before this point. They are          *)
(* not defined here so that the choice of a model for MTProto's encryption    *)
(* scheme can be done independently, without touching this file.              *)
(*                                                                            *)
(* The reference for MTProto's encryption scheme for cloud chat n             *)
(*                                                                            *)
(*    https://core.telegram.org/mtproto/description                           *)
(*                                                                            *)
(******************************************************************************)

(* fpk(PubKey): HashValue *)
(* keyID(SharedKey): HashValue *)
(* encodeRequestDHParams(Plaintext, PubKey): Ciphertext *)
(* decodeRequestDHParams(Ciphertext, PrivKey): Plaintext *)
(* encodeAuthorizationMsg(Plaintext, SharedKey, Nonce): Ciphertext *)
(* decodeAuthorizatioMsg(Ciphertext, SharedKey, Nonce): Plaintext *)
(* hashNk(Nonce, AuthKey): HashValue *)


(******************************************************************************)
(* Decomposition into prime factors.                                          *)
(*                                                                            *)
(* This is used only for proof-of-work, a measure against DoS, which we do    *)
(* not include in our threat model. This definition is reported here for the  *)
(* sake of completeness, but it is never used.                                *)
(******************************************************************************)
type Prime.

fun mult(Prime, Prime): bitstring.

reduc forall x: Prime, y: Prime;
  factorise(mult(x,y)) = (x,y).


(******************************************************************************)
(* Messages exchanged during the authorization protocol                       *)
(******************************************************************************)

(* Round 1 *)
fun NC(Nonce)                           : Message   [data]. (* Client -> Server *)
fun NS(Nonce, Nonce, HashValue)         : Message   [data]. (* Server -> Client *)

(* Round 2 *)
fun REQDH(Nonce, Nonce, Ciphertext)     : Message   [data]. (* Client -> Server *)
fun DH   (Nonce, Nonce, Ciphertext)     : Message   [data]. (* Server -> Client *)

(* Round 3 *)
fun ENDH(Nonce, Nonce, Ciphertext)      : Message   [data]. (* Client -> Server *)
fun ACK (Nonce, Nonce, HashValue)       : Message   [data]. (* Server -> Client *)

(* Constructors for the encrypted portions of the messages *)
fun D1(Nonce, Nonce, Nonce)             : Plaintext [data]. (* encData1 *)
fun AN(Nonce, Nonce, Modulus, G, G)     : Plaintext [data]. (* encAnswer *)
fun D2(Nonce, Nonce, G)                 : Plaintext [data]. (* encData2 *)


(******************************************************************************)
(* Persistent state (tables)                                                  *)
(******************************************************************************)

(* Records a client's session secrets *)
table AuthProtClientEphemeralSecrets(Nonce, Z).

(* Records the full client's session state *)
table AuthProtClientSessionState(Nonce, Nonce, Nonce, Modulus, G, G, Z).

(*
 * Records the ephemeral session state of the server, that is, the ephemeral
 * Diffie-Hellman exponent b.
 *)
table AuthProtServerEphemeralSecrets(Z).

(* Records the full server's session state *)
table AuthProtServerSessionState(Nonce, Nonce, Nonce, Modulus, G, Z, G).

(*
 * Stores the Diffie-Hellman parameters generated by the server.
 *)
table DiffieHellmanParametersTable(Modulus, G).


(******************************************************************************)
(* Events                                                                     *)
(******************************************************************************)

(*
 * ClientStartsSession(nc):
 *
 * "A client starts a run of the authorization protocol proposing a random nonce nc."
 *)
event ClientStartsSession(Nonce).

(*
 * ClientGetsServerPublicKey(nc, k):
 *
 * "The client who has started the protocol with nonce nc has retrieved the
 * public key k of the server."
 *)
event ClientGetsServerPublicKey(Nonce, PubKey).

(*
 * ClientRequestsDHParameters(nc, ns, nk):
 *
 * "The client running session (nc,ns) requests DH parameters by sending o secret nonce nk."
 *)
event ClientRequestsDHParameters(Nonce, Nonce, Nonce).

(*
 * ClientReceivesDHParameters(nc, ns, nk, p, g, g_s):
 *
 * "The client running session (nc,ns) with ephemeral nonce nk has received DH
 * parameters (p,g) and the server's half key g_s."
 *)
event ClientReceivesDHParameters(Nonce, Nonce, Nonce, Modulus, G, G).

(*
 * ClientChecksDHParameters(nc, ns, nk, p, g, g_s, B):
 *
 * "The client (B ? 'validates' : 'does not validate') the received DH
 * parameters in the session identified by the given session state (nc,ns,nk,p,g,g_s)."
 *)
event ClientChecksDHParameters(Nonce, Nonce, Nonce, Modulus, G, G, bool).

(*
 * ClientAcceptsDHParameters(nc, ns, nk, p, g, g_s):
 *
 * "The client running in the session identified by session state (nc,ns,nk)
 * has accepted the DH parameters (p,g) after receiving the half key g_s."
 *)
event ClientAcceptsDHParameters(Nonce, Nonce, Nonce, Modulus, G, G).

(*
 * ClientEndsDHExchange(nc, ns, nk, p, g, g_s, b, k):
 *
 * "The client completes the authorization protocol in the session identified by
 * the given session state."
 *)
event ClientEndsDHExchange(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).

(*
 * ClientAcceptsAuthKey(nc, ns, nk, p, g, g_s, b, k):
 *
 * "The client has negotiated the authorization key k in the session identified
 * by the given session state."
 *)
event ClientAcceptsAuthKey(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).

(*
 * ClientReceivesAck(nc, ns, nk, p, g, g_a, b, k):
 *
 * "The client has received the acknowledgment message in the session
 * identified by the given session state."
 *)
event ClientReceivesAck(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).

(*
 * ServerReceivesRequest(nc):
 *
 * "The server has received a request to start a run of the authorization
 * protocol with client nonce nc."
 *)
event ServerReceivesRequest(Nonce).

(*
 * ServerGeneratesNonce(p, ns):
 *
 * "The server process p has generated nonce ns."
 *)
event ServerGeneratesNonce(ProcessID, Nonce).

(*
 * ServerAcceptsClient(nc, ns, nk):
 *
 * "The server has accepted a request to generate an authorization key in
 * session (nc,ns), for a client who has sent a secret nonce nk."
 *)
event ServerAcceptsClient(Nonce, Nonce, Nonce).

(*
 * ServerSendsDHParameters(nc, ns, nk, p, g, g_s):
 *
 * "The server sends DH parameters (p,g) and its half-key g_s to a client who has
 * started session (nc,ns) and sent secret nonce nk."
 *)
event ServerSendsDHParameters(Nonce, Nonce, Nonce, Modulus, G, Z).

(*
 * ServerEndsDHExchange(nc, ns, nk, p, g, a, g_c, k).
 *
 * "The server completes the DH exchange with parameters (p,g) in session
 * (nc,ns) for which a client has generated the secret nonce nk and the
 * half-key g_c by computing the authorization key k."
 *)
event ServerEndsDHExchange(Nonce, Nonce, Nonce, Modulus, G, Z, G, AuthKey).

(*
 * ServerAcceptsAuthKey(nc, ns, nk, p, g, a, g_c, k):
 *
 * "The server has negotiated the authorization key k with a client in a
 * session identified by the given session state."
 *)
event ServerAcceptsAuthKey(Nonce, Nonce, Nonce, Modulus, G, Z, G, AuthKey).

(*
 * ServerSendsAck(nc, ns, nk, p, g, a, g_b, k):
 *
 * "The server sends an acknowledgment to a client in the session identified by the given session state."
 *)
event ServerSendsAck(Nonce, Nonce, Nonce, Modulus, G, Z, G, AuthKey).

(*
 * RevealedRSAKey(k):
 *
 * "The attacker gains knowledge of the server's private key k."
 *)
event RevealedRSAKey(PrivKey).

(*
 * RevealedAuthKey(k):
 *
 * "The attacker reveals the authorization key computed by a client."
 *)
event RevealedAuthKey(AuthKey).

(*
 * RevealedClientAuthKey(k):
 *
 * "The attacker reveals the authorization key computed by a client."
 *)
event RevealedClientAuthKey(AuthKey).

(*
 * RevealedServerAuthKey(k):
 *
 * "The attacker reveals the authorization key computed by the server."
 *)
event RevealedServerAuthKey(AuthKey).

(*
 * RevealedNk(nk):
 *
 * "The attacker gains knowledge of the client's secret nonce nk."
 *)
event RevealedNk(Nonce).

(*
(*
 * RevealedAuthProtClientExponent(b):
 *
 * "The attacker gains knowledge of the client's secret exponent b."
 *)
event RevealedAuthProtClientExponent(Z).


(* RevealedAuthProtClientEphemeralSecrets(nk, b):
 *
 * "The attackers reveals the client's session secrets."
 *)
event RevealedAuthProtClientEphemeralSecrets(Nonce, Z).

(*
 * RevealedServerEphemeralSecrets(a):
 *
 * "The attackers reveals the server's session secret."
 *)
event RevealedAuthProtServerExponent(Z).

(*
 * PostCompromisedRSAKey(k):
 *
 * "The attacker gains knowledge of the server's private key k after the
 * authorization protocol has been carried out completely."
 *)
event PostCompromisedRSAKey(PrivKey).

(*
 * PostCompromisedAuthKey(k):
 *
 * "The attacker gains knowledge of the authorization key k after the
 * authorization protocol has been carried out completely."
 *)
event PostCompromisedAuthKey(AuthKey).

(*
 * PostCompromisedNk(nk):
 *
 * "The attacker gains knowledge of the client's secret nonce nk after the
 * authorization protocol has been carried out completely."
 *)
event PostCompromisedNk(Nonce).

(*
 * PostCompromisedAuthProtClientExponent(b):
 *
 * "The attacker reveals the client's session state after the authorization
 * protocol has completed."
 *)
event PostCompromisedAuthProtClientExponent(Z).

(*
 * PostCompromisedAuthProtServerExponent(a):
 *
 * "The attacker reveals the server's session secret after the authorization
 * protocol has completed."
 *)
event PostCompromisedAuthProtServerExponent(Z).


(******************************************************************************)
(* Process macros for client and server                                       *)
(******************************************************************************)

(*
 * Telegram client
 *
 * server: server's identity (e.g., IP address)
 *)
let ClientAuth(server: Principal, allowWeakDH: bool) =

  (* Ephemeral session secrets *)
  new nk: Nonce;
  new b: Z;

  (* Store ephemeral secrets so that they can be revealed by another process *)
  insert AuthProtClientEphemeralSecrets(nk, b);

  in(io, X: Principal);
  let cUser = choosePrincipal(X, Alice, Bob) in

  (* 1. The client initiates a session to negotiate an authorization key. *)
  new nc: Nonce;

  event ClientStartsSession(nc);

  out(io, NC(nc));

  (* 3. *)
  in(io, NS(=nc, ns, fp));

  get RSAPublicKeyTable(=server, pks, =fp) in

  event ClientGetsServerPublicKey(nc, pks);

  (* 4. Start of DH exchange *)

  let encData1 = encodeRequestDHParams(D1(nc, ns, nk), pks) in

  event ClientRequestsDHParameters(nc, ns, nk);

  out(io, REQDH(nc, ns, encData1));

  (* 6 *)
  in(io, DH(=nc, =ns, encAnswer: Ciphertext));

  let AN(=nc, =ns, p, g, g_a) = decodeAuthorizatioMsg(encAnswer, ns, nk) in

  event ClientReceivesDHParameters(nc, ns, nk, p, g, g_a);

  (*
   * Allow the process to continue only if the Diffie-Hellman parameters are good,
   * or we have explicitly allowed weak parameters.
   *)
  let unused = continue_if(allowWeakDH || (p <> WEAK && g <> BAD && g_a <> BAD)) in

  (*
   * A broken client might accept DH parameters unconditionally. The following
   * event allows us to test whether the client is running the protocol with
   * bad parameters (in which case it is assumed that it has not checked them)
   * or with strong parameters (in which case it is assumed that it has checked
   * them).
   *)
  event ClientChecksDHParameters(nc, ns, nk, p, g, g_a, p <> WEAK && g <> BAD && g_a <> BAD);
  event ClientAcceptsDHParameters(nc, ns, nk, p, g, g_a);

  (* 7 *)

  insert AuthProtClientSessionState(nc, ns, nk, p, g, g_a, b);

  let authKey = group2auth(dhExp(p, g_a, b)) in
  let g_b = dhExp(p, g, b) in

  (* 8 *)
  let encData2 = encodeAuthorizationMsg(D2(nc, ns, g_b), ns, nk) in

  event ClientEndsDHExchange(nc, ns, nk, p, g, g_a, b, authKey);
  event ClientAcceptsAuthKey(nc, ns, nk, p, g, g_a, b, authKey);

  out(io, ENDH(nc, ns, encData2));

  (* DH exchange completed, waiting for acknowledgment from the server *)
  in(io, ACK(=nc, =ns, =hashNk(nk, authKey)));

  event ClientReceivesAck(nc, ns, nk, p, g, g_a, b, authKey);

  (* Protocol ends here. The following is for testing queries *)

  (* Store the authKey for use by the other protocols *)
  insert AuthKeyClientTable(cUser, server, authKey);
  0.


(*
 * Telegram server
 *
 * server: server's identity (e.g., IP address).
 *)
let ServerAuth(server: Principal) =
  (*
   * The following fresh name is used only inside events, to distinguish
   * different copies of this process.
   *)
  new sPID: ProcessID;

  (* Ephemeral session secrets *)
  new a: Z;

  (* Store ephemeral secrets so that they can be revealed by another process *)
  insert AuthProtServerEphemeralSecrets(a);

  get RSAServerKeyTable(=server, sks, pks) in

  (*
   * Get DH parameters from one of two parallel processes, one that generates
   * good values, and another one that generates bad values.
   *
   * NOTE: this appears to allow for significantly faster verification times
   * than using in(io, (p: Modulus, g: G));
   *)
  get DiffieHellmanParametersTable(p,g) in

  (* 2 *)
  in(io, NC(nc));

  event ServerReceivesRequest(nc);

  (*
   * The generation of the server's nonce is left to the attacker
   *)
  in(io, ns: Nonce);

  event ServerGeneratesNonce(sPID, ns);

  out(io, NS(nc, ns, fpk(pks)));

  (* 5 *)
  in(io, REQDH(=nc, =ns, encData1: Ciphertext));
  let D1(=nc, =ns, nk: Nonce) = decodeRequestDHParams(encData1, sks) in

  event ServerAcceptsClient(nc, ns, nk);

  let g_a        = dhExp(p, g, a) in
  let encAnswer  = encodeAuthorizationMsg(AN(nc, ns, p, g, g_a), ns, nk) in

  event ServerSendsDHParameters(nc, ns, nk, p, g, a);

  out(io, DH(nc, ns, encAnswer));

  (* 9. DH exchange complete *)
  in(io, ENDH(=nc, =ns, encData2: Ciphertext));
  let D2(=nc, =ns, g_b) = decodeAuthorizatioMsg(encData2, ns, nk) in
  let authKey = group2auth(dhExp(p, g_b, a)) in

  insert AuthProtServerSessionState(nc, ns, nk, p, g, a, g_b);

  event ServerEndsDHExchange(nc, ns, nk, p, g, a, g_b, authKey);

  event ServerAcceptsAuthKey(nc, ns, nk, p, g, a, g_b, authKey);

  event ServerSendsAck(nc, ns, nk, p, g, a, g_b, authKey);

  out(io, ACK(nc, ns, hashNk(nk, authKey)));

  (* Protocol ends here. The following is for testing queries. *)

  (* Store the authKey for use by the other protocols *)
  insert AuthKeyServerTable(keyID(auth2shared(authKey)), authKey);
  0.


(******************************************************************************)
(* Auxiliary processes                                                        *)
(******************************************************************************)

(* Generates a new private/public key pair for the given server *)
let RegisterRSAKey(server: Principal) =
  new sk: PrivKey;
  insert RSAServerKeyTable(server, sk, pk(sk)); (* Accessed only by the server *)
  insert RSAPublicKeyTable(server, pk(sk), fpk(pk(sk))); (* Used by the client *)
  out(io, pk(sk)); (* Publish the public key *)
  out(io, server);  (* Make the server's identity public *)
  0.

(*
 * Leaks a server's private key.
 *
 * NOTE: run in parallel with RegisterRSAKey(), this also captures the
 * situation in which the server's identity is compromised to begin with, i.e.,
 * the case in which the client's public key does not correspond to the real
 * server, but to an attacker-controlled server.
 *)
let RevealRSAKey() =
  get RSAServerKeyTable(server, sk, pk_unused) in
  event RevealedRSAKey(sk);
  out(io, sk).

let RevealAuthKey() =
  get AuthKeyClientTable(client, server, authKey) in
  event RevealedAuthKey(authKey);
  out(io, authKey).

let RevealClientAuthKey() =
  get AuthKeyClientTable(client, server, authKey) in
  event RevealedClientAuthKey(authKey);
  out(io, authKey).

let RevealServerAuthKey() =
  get AuthKeyServerTable(keyid, authKey) in
  event RevealedServerAuthKey(authKey);
  out(io, authKey).

(* Privately receives a secret nonce from a client and leaks it *)
let RevealNk() =
  get AuthProtClientEphemeralSecrets(nk: Nonce, b: Z) in
  event RevealedNk(nk);
  out(io, nk).

let RevealAuthProtClientExponent() =
  get AuthProtClientEphemeralSecrets(nk: Nonce, b: Z) in
  event RevealedAuthProtClientExponent(b);
  out(io, b).

let RevealAuthProtClientEphemeralSecrets() =
  get AuthProtClientEphemeralSecrets(nk: Nonce, b: Z) in
  event RevealedAuthProtClientEphemeralSecrets(nk, b);
  out(io, (nk, b)).

let RevealAuthProtServerExponent() =
  get AuthProtServerEphemeralSecrets(a: Z) in
  event RevealedAuthProtServerExponent(a);
  out(io, a).

(*
 * Post-compromise attacks.
 *)

(* Reveals the private key of the server after the protocol has been run *)
let PostCompromiseRSAKey() =
  phase 1;
  get RSAServerKeyTable(server, sk, pk_unused) in
  event PostCompromisedRSAKey(sk);
  out(io, sk).

(* Reveals an authorization key after the protocol has been run *)
let PostCompromiseAuthKey() =
  phase 1;
  get AuthKeyServerTable(fp, authKey) in
  event PostCompromisedAuthKey(authKey);
  out(io, authKey).

(* Reveals the secret nonce generated by the client after the protocol has been run *)
let PostCompromiseNk() =
  phase 1;
  get AuthProtClientEphemeralSecrets(nk: Nonce, b: Z) in
  event PostCompromisedNk(nk);
  out(io, nk).

(* Reveals the secret nonce generated by the client after the protocol has been run *)
let PostCompromiseAuthProtClientExponent() =
  phase 1;
  get AuthProtClientEphemeralSecrets(nk: Nonce, b: Z) in
  event PostCompromisedAuthProtClientExponent(b);
  out(io, b).


(* Reveals the ephemeral key of the server (the DH exponent) after the protocol
* has been completed *)
let PostCompromiseAuthProtServerExponent() =
  phase 1;
  get AuthProtServerEphemeralSecrets(a: Z) in
  event PostCompromisedAuthProtServerExponent(a);
  out(io, a).


(*
 * Utility processes.
 *)

(*
 * Generate strong Diffie-Hellman parameters on behalf of the server.
 *)
let GenGoodDHParameters() =
  insert DiffieHellmanParametersTable(STRONG,GOOD).

(*
 * Generate bad Diffie-Hellman parameters on behalf on the server.
 *)
let GenBadDHParameters() =
  new g: G;
  insert DiffieHellmanParametersTable(WEAK, g);
  insert DiffieHellmanParametersTable(STRONG, BAD);
  out(io, g).

(*
 * Allow the attacker to register an authorization key for itself with a
 * server.
 *)
let RegisterAuthKey() =
  in(io, (X: Principal, k: AuthKey));
  if X <> Alice && X <> Bob then
    insert AuthKeyServerTable(keyID(auth2shared(k)), k);
    0.

