(*
  MTProto 2.0: Creating an authorization key.

  Model for the protocol used to create long-term keys
  shared between a client and Telegram's server.

  See: https://core.telegram.org/mtproto/auth_key
*)


(******************************************************************************)
(* Messages exchanged during the authorization protocol                       *)
(******************************************************************************)
type Message.

fun msg2bit(Message): bitstring [typeConverter].

(* Round 1 *)
fun NC(Nonce)                                                : Message [data].
fun NS(Nonce, Nonce, bitstring, Fingerprint)                 : Message [data].

(* Round 2 *)
fun REQDH(Nonce, Nonce, Prime, Prime, Fingerprint, bitstring): Message [data].
fun DH(Nonce, Nonce, bitstring):                               Message [data].

(* Round 3 *)
fun ENDH(Nonce, Nonce, bitstring)                            : Message [data].
fun ACK(Nonce, Nonce, bitstring)                             : Message [data].

(* Constructors for hashed data *)
fun HD(bitstring, bitstring): bitstring [data].

fun dataWithHash(bitstring): bitstring
  reduc forall x: bitstring;
    dataWithHash(x) = HD(sha1(x), x).

(* Constructors for the encrypted portions of the messages *)
fun D1(bitstring, Prime, Prime, Nonce, Nonce, Nonce): bitstring [data]. (* data1 *)
fun AN(Nonce, Nonce, Elem, Group, Elem, bitstring)  : bitstring [data]. (* answer *)
fun D2(Nonce, Nonce, bitstring, Elem)               : bitstring [data]. (* data2 *)

(* Server acknowledgment messages *)
fun nkHash(Nonce, SharedKey): bitstring
  reduc forall n: Nonce, k: SharedKey;
    nkHash(n,k) = sha1((n,1,sha1(key2bit(k)))).

(* Temp AES key and IV creation *)
fun genKey(Nonce, Nonce): SharedKey.
fun genIV (Nonce, Nonce): InitV.

(* Broken/untrusted server may reuse the same nonce in multiple sessions *)
const REUSED_NONCE: Nonce.

(******************************************************************************)
(* Events                                                                     *)
(******************************************************************************)
event ClientStartsSession         (Principal, Principal, Nonce).
event ClientGetsServerPublicKey   (Principal, PubKey).
event ClientRequestsDHParameters  (Principal, Nonce, Nonce, Nonce).
event ClientReceivesDHParameters  (Principal, Nonce, Nonce, Nonce, Elem,  Group, Elem).
event ClientReceivesDHParameters2 (Nonce, Nonce).
event ClientChecksDHParameters    (bool).
event ClientAcceptsDHParameters   (Principal, Nonce, Nonce, Nonce, Elem,  Group, Elem).
event ClientEndsDHExchange        (Nonce,     Nonce, Nonce, Elem,  Group, Elem,  Elem, SharedKey).
event ClientAcceptsAuthKey        (Nonce,     Nonce, SharedKey).
event ClientReceivesAck           (Nonce,     Nonce).
event ClientSendsSecretMessage    (Principal, bitstring, SharedKey).
event ClientSendsSecretMessageAfterCompromisedNonce(Principal, bitstring, SharedKey).

event ServerReceivesRequest       (Principal, Nonce, Nonce, PubKey).
event ServerReusesNonce           (Principal, bool).
event ServerAcceptsClient         (Principal, Nonce, Nonce, Nonce).
event ServerSendsDHParameters     (Principal, Nonce, Nonce, Nonce, Elem, Group, Elem).
event ServerSendsDHParameters2    (Nonce, Nonce).
event ServerEndsDHExchange        (Principal, Nonce, Nonce, Nonce, Elem, Group, Elem, SharedKey).
event ServerAcceptsAuthKey        (Principal, Nonce, Nonce, SharedKey).
event ServerSendsAck              (Principal, Nonce, Nonce, Nonce).
event ServerReceivesSecretMessage (Principal, bitstring, SharedKey).
event ServerReceivesSecretMessageAfterCompromisedNonce(Principal, bitstring, SharedKey).


(******************************************************************************)
(* Process macros for client and server                                       *)
(******************************************************************************)

(*
  Telegram client
*)
let ClientAuth(cID: Principal, s: Principal, ct: ClientType) =
  (* 1. Client initiates a session to negotiate an authorization key. *)
  new nc: Nonce;

  event ClientStartsSession(cID, s, nc);

  out(io, NC(nc));

  (* 3. Proof of work *)
  in(io, NS(=nc, ns, pq, fps));
  let (p: Prime, q: Prime) = factorise(pq) in

  (* 4. Start of DH exchange *)
  get RSAPublicKeyTable(=s, pks, =fps) in

  event ClientGetsServerPublicKey(s, pks);

  new nk: Nonce; (* Secret nonce which should be known only to client and server *)

  let data1    = D1(pq, p, q, nc, ns, nk) in
  let encData1 = rsaEnc(dataWithHash(data1), pks) in

  event ClientRequestsDHParameters(s, nc, ns, nk);

  out(io, REQDH(nc, ns, p, q, fps, encData1));

  (* Leak the secret nonce *)
  (* We would like to model this as a parallel process, but that significantly  *)
  (* increases the computation times. So, to verify some queries, you will have *)
  (* to uncomment the following two lines: this is indicated in the comment     *)
  (* accompanying each query.                                                   *)
  (* event CompromisedNonce(nk); *)
  (* out(io, nk); *)

  (* 6 *)
  in(io, DH(=nc, =ns, encAnswer: bitstring));

  let k  = genKey(ns, nk) in
  let iv = genIV (ns, nk) in
  let HD(tagAnswer, answer) = aesDec(encAnswer, k, iv) in

  if tagAnswer = sha1(answer) then
    let AN(=nc, =ns, g, m, g_a, timestamp) = answer in

    (* event ClientReceivesDHParameters(s, nc, ns, nk, g, m, g_a); *)
    event ClientReceivesDHParameters2(nc, ns);
    event ClientChecksDHParameters(ct <> BROKEN_CLIENT);

    (* A broken client accepts DH parameters unconditionally *)
    if ct = BROKEN_CLIENT || (g_a <> BAD_ELEM && m <> WEAK_DH && g <> BAD_ELEM) then

      event ClientAcceptsDHParameters(s, nc, ns, nk, g, m, g_a);

      (* 7 *)
      let (b: Exp, authKey: SharedKey) = dhKeyGen(g_a, m) in
      let g_b = dhExp(m, g, b) in

      (* 8 *)
      new retry_id: bitstring;
      let data2    = D2(nc, ns, retry_id, g_b) in
      let encData2 = aesEnc(dataWithHash(data2), k, iv) in

      event ClientEndsDHExchange(nc, ns, nk, g, m, g_a, g_b, authKey);
      event ClientAcceptsAuthKey(nc, ns, authKey);

      out(io, ENDH(nc, ns, encData2));

      (* DH exchange completed, waiting for acknowledgment from the server *)
      in(io, ACK(=nc, =ns, ackHash));

      if ackHash = nkHash(nk, authKey) then
        event ClientReceivesAck(nc, ns);

        event ClientSendsSecretMessage(s, secretMsg, authKey);
        new r: Nonce;
        out(io, aenc(secretMsg, authKey, r));

        phase 1;
        event PostCompromisedNonce(nk);
        out(io, nk);
        event ClientSendsSecretMessageAfterCompromisedNonce(s, secretMsg, authKey);
        new r: Nonce;
        out(io, aenc(secretMsg, authKey, r));

        phase 2;
        in(io, attack(=ATTACK));
        event PostCompromisedKey(authKey);
        out(io, authKey);
        0.


(*
  Telegram server

  The server's nonce is passed as an argument to this process, so we may test
  servers that reuse the same nonce.
*)
let ServerAuth(s: Principal, n: Nonce) =
  get RSAServerKeyTable(=s, sks, pks) in

  (*
    We model a possible malicious choice of Diffie-Hellman parameters by the
    server by letting the attacker choose such parameters and send them to the
    server.
  *)
  in(io, dh: DHParam);
  let dhParam(g,m) = dh in

  (* 2 *)
  in(io, NC(nc));

  let ns  = n in
  new p   : Prime;
  new q   : Prime;
  let pq  = mult(p,q) in
  let fps = fp(pks) in

  event ServerReceivesRequest(s, nc, ns, pks);
  event ServerReusesNonce(s, ns = REUSED_NONCE);

  out(io, NS(nc, ns, pq, fps));

  (* 5 *)
  in(io, REQDH(=nc, =ns, =p, =q, =fps, encData1: bitstring));
  let HD(tag1, data1) = rsaDec(encData1, sks) in
  if tag1 = sha1(data1) then
    let D1(=pq, =p, =q, =nc, =ns, nk) = data1 in

    event ServerAcceptsClient(s, nc, ns, nk);

    new a   : Exp;
    let g_a = dhExp(m, g, a) in

    new server_time: bitstring;
    let k          = genKey(ns, nk) in
    let iv         = genIV (ns, nk) in
    let answer     = AN(nc, ns, g, m, g_a, server_time) in
    let encAnswer  = aesEnc(dataWithHash(answer), k, iv) in

    event ServerSendsDHParameters2(nc, ns);

    out(io, DH(nc, ns, encAnswer));

    (* 9. DH exchange complete *)
    in(io, ENDH(=nc, =ns, encData2: bitstring));
    let HD(tag2, data2) = aesDec(encData2, k, iv) in
    if tag2 = sha1(data2) then
      let D2(=nc, =ns, retry_id, g_b) = data2 in
      let authKey = elem2key(dhExp(m, g_b,a)) in

      event ServerEndsDHExchange(s, nc, ns, nk, g, m, g_a, authKey);
      event ServerAcceptsAuthKey(s, nc, ns, authKey);
      event ServerSendsAck(s, nc, ns, nk);

      out(io, ACK(nc, ns, nkHash(nk, authKey)));

      in(io, (f: bitstring, mk: bitstring, encMsg: bitstring));
      let msg = adec(encMsg, authKey) in
      event ServerReceivesSecretMessage(s, msg, authKey);

      phase 1;
      in(io, (f: bitstring, mk: bitstring, encMsg: bitstring));
      let msg = adec(encMsg, authKey) in
      event ServerReceivesSecretMessageAfterCompromisedNonce(s, msg, authKey);

      phase 2;
      event PostCompromiseRSAKey(sks);
      out(io, sks);
      0.


(******************************************************************************)
(* Auxiliary processes exfiltrating data                                      *)
(******************************************************************************)

let RSAKeys(s: Principal) =
  new k: PrivKey;
  insert RSAServerKeyTable(s, k, pk(k));
  insert RSAPublicKeyTable(s, pk(k), fp(pk(k)));
  out(io, pk(k));
  in(io, attack(=ATTACK));
  event CompromisedRSAKey(k);
  out(io, k).

