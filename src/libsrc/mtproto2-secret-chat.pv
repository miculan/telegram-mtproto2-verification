(*
  MTProto 2.0: Secret Chats

  Model for the protocol used in secret chats.

  See: https://core.telegram.org/api/end-to-end
*)

(******************************************************************************)
(* Messages exchanged during the authorization protocol                       *)
(******************************************************************************)
fun GET_DH_CONFIG()                                            : bitstring [data].
fun DH_CONFIG(Elem, Group)                                     : bitstring [data].
fun REQA(bitstring, Principal, Elem)                           : bitstring [data].
fun REQB(bitstring, Principal, Principal, Elem)                : bitstring [data].
fun CHAT_ACCEPTED(bitstring)                                   : bitstring [data].
fun ACCEPTB(bitstring, Elem, bitstring)                        : bitstring [data].
fun ACCEPTA(bitstring, Principal, Principal, Elem, bitstring)  : bitstring [data].
fun CHAT(bitstring, bitstring, bitstring)                      : bitstring [data].

(*
  Private, out-of-band, verification of the key
*)
fun qr  (Principal, Principal, SharedKey): bitstring [data].
fun qrOK(Principal, SharedKey)           : bitstring [data].

(******************************************************************************)
(* Events                                                                     *)
(******************************************************************************)
event ClientRequestsDHConfig(Principal).
event ClientChecksDHConfig(Principal, bool).
event ClientRequestsEncryptedChat(bitstring, Principal, Principal). (* chat id, initiator, responder *)
event ClientReceivesRequestForEncryptedChat(bitstring, Principal, Principal, Elem).
event ClientAcceptsClient(bitstring, Principal, Principal). (* chat id, initiator, responder *)
event ClientHasSessionKeyForEncryptedChat(Principal, bitstring, Principal, Principal, SharedKey).
event ClientAcceptsEncryptedChat(Principal, bitstring, Principal, Principal, SharedKey).
event ClientSkipsKeyCheck(Principal, SharedKey, bool).
event ClientSendsMessageToEncryptedChat(bitstring, Principal, Principal, SharedKey, bitstring).
event ClientReceivesMessageInEncryptedChat(bitstring, Principal, Principal, SharedKey, bitstring).


(******************************************************************************)
(* Main process macros                                                        *)
(******************************************************************************)

(*
  Secure, private, out-of-band channel between initiator and responder.
*)
free oob: channel [private].

(* Client A (Initiator) *)
let ChatInitiator(iID: Principal, authKeyI: SharedKey, rID: Principal, ct: ClientType) =
  let fI = fingerprint(authKeyI) in

  event ClientRequestsDHConfig(iID);

  out(io, encodeMsgSC(authKeyI, GET_DH_CONFIG()));

  in(io, MSG(=fI, mk2, encData2));

  let MSG(=fI, =mk2, DH_CONFIG(g,p)) = decodeMsgChatClient(authKeyI, mk2, encData2) in

  event ClientChecksDHConfig(iID, ct <> BROKEN_CLIENT);

  (* Broken clients accept Diffie-Hellman parameters unconditionally *)
  if ct = BROKEN_CLIENT || (g <> BAD_ELEM && p <> WEAK_DH) then

    new a: Exp;
    let g_a = dhExp(p, g, a) in
    new chatID: bitstring;

    event ClientRequestsEncryptedChat(chatID, iID, rID);

    out(io, encodeMsgSC(authKeyI, REQA(chatID, rID, g_a)));

    in(io, MSG(=fI, mk8, encData8));

    let MSG(=fI, =mk8, ACCEPTA(=chatID, =iID, =rID, g_b, sessFp)) = decodeMsgChatClient(authKeyI, mk8, encData8) in

    if ct = BROKEN_CLIENT || g_b <> BAD_ELEM then
      let sessKey = elem2key(dhExp(p, g_b, a)) in
      if sessFp = fingerprint(sessKey) then

        event ClientHasSessionKeyForEncryptedChat(iID, chatID, iID, rID, sessKey);

        event ClientSkipsKeyCheck(iID, sessKey, ct = SKIPS_KEY_CHECK);
        if ct = SKIPS_KEY_CHECK then
          (
          new r: Nonce;
          let encMsg = aenc(secretMsg, sessKey, r) in
          new randomID: bitstring;

          event ClientSendsMessageToEncryptedChat(chatID, iID, rID, sessKey, secretMsg);

          out(io, encodeMsgSC(authKeyI, CHAT(chatID, randomID, encMsg)))
          )
        else
          (
          out(oob, qr(iID, rID, sessKey));
          in(oob, qrOK(=rID, =sessKey));

          new r: Nonce;
          let encMsg = aenc(secretMsg, sessKey, r) in
          new randomID: bitstring;

          event ClientSendsMessageToEncryptedChat(chatID, iID, rID, sessKey, secretMsg);

          out(io, encodeMsgSC(authKeyI, CHAT(chatID, randomID, encMsg)))
          ).


(* Client B (Responder) *)
let ChatResponder(rID: Principal, authKeyR: SharedKey, ct: ClientType) =
  let fR = fingerprint(authKeyR) in

  in(io, MSG(=fR, mk4, encData4));
  let MSG(=fR, =mk4, REQB(chatID, iID, =rID, g_a)) = decodeMsgChatClient(authKeyR, mk4, encData4) in

  event ClientReceivesRequestForEncryptedChat(chatID, iID, rID, g_a);

  (* Prevent a client to chat with itself *)
  if iID <> rID then

    event ClientAcceptsClient(chatID, iID, rID);

    out(io, encodeMsgSC(authKeyR, CHAT_ACCEPTED(chatID)));

    in(io, MSG(=fR, mk6, encData6));
    let MSG(=fR, =mk6, DH_CONFIG(g,p)) = decodeMsgChatClient(authKeyR, mk6, encData6) in

    event ClientChecksDHConfig(rID, ct <> BROKEN_CLIENT);

    (* Broken clients accept Diffie-Hellman parameters unconditionally *)
    if ct = BROKEN_CLIENT || (g <> BAD_ELEM && p <> WEAK_DH && g_a <> BAD_ELEM) then

      new b: Exp;
      let g_b = dhExp(p, g, b) in
      let sessKey = elem2key(dhExp(p, g_a, b)) in
      let sessFp = fingerprint(sessKey) in

      event ClientHasSessionKeyForEncryptedChat(rID, chatID, iID, rID, sessKey);
      event ClientAcceptsEncryptedChat(rID, chatID, iID, rID, sessKey);

      out(io, encodeMsgSC(authKeyR, ACCEPTB(chatID, g_b, sessFp)));

      event ClientSkipsKeyCheck(rID, sessKey, ct = SKIPS_KEY_CHECK);
      if ct <> SKIPS_KEY_CHECK then
        (
        in(oob, qr(=iID, =rID, =sessKey));
        out(oob, qrOK(rID, sessKey));

        in(io, MSG(=fR, mk10, encData10));
        let MSG(=fR, =mk10, CHAT(=chatID, randomID, MSG(=sessFp, mks, encMsg))) = decodeMsgChatClient(authKeyR, mk10, encData10) in
        let msg = adec(encMsg, sessKey) in

        event ClientReceivesMessageInEncryptedChat(chatID, iID, rID, sessKey, msg)
        )
      else
        (
        in(io, MSG(=fR, mk10, encData10));
        let MSG(=fR, =mk10, CHAT(=chatID, randomID, MSG(=sessFp, mks, encMsg))) = decodeMsgChatClient(authKeyR, mk10, encData10) in
        let msg = adec(encMsg, sessKey) in

        event ClientReceivesMessageInEncryptedChat(chatID, iID, rID, sessKey, msg)
        ).

