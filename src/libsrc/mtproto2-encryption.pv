(******************************************************************************)
(* MTProto 2.0: Encryption scheme                                             *)
(*                                                                            *)
(* See: https://core.telegram.org/mtproto                                     *)
(******************************************************************************)

(*
  MTProto's encryption scheme is better analyzed in the computational model
  rather than symbolically. For this reason, we assume that the scheme is an
  authenticated encryption (AE) scheme (IND-CPA and INT-CTXT) and we use the
  following symbolic model for AE in our model. In other words, we treat the
  full encryption scheme as a cryptographic primitive.

  NOTE: whether MTProto 2.0 is IND-CPA and INT-CTXT is still an open question.
*)

fun aenc(bitstring, SharedKey, Nonce): bitstring.
reduc forall m: bitstring, k: SharedKey, r: Nonce;
  adec(aenc(m,k,r),k) = m.


(******************************************************************************)


(*
  The following definitions, reported here for the sake of completeness, model
  the encryption scheme in a way that is closer to what MTProto does. Since the
  underlying symmetric encryption is modeled as a perfectly secure
  authenticated encryption scheme, however, a symbolic analysis using the model
  below would consider the message encryption scheme as secure even if the
  message key mechanism were omitted, because it ignores the malleability
  properties of AES in IGE mode. Since malleability is difficult to model
  symbolically, we have decided to use the simpler abstraction above (aenc()
  and dec()), and leave the verification of the full encryption scheme as
  future work to be carried out with a tool such as CryptoVerif.

  Using the model below or the simpler abstraction above does not change any
  result in the symbolic verification of MTProto.
*)

(* MTProto message constructor *)
fun MSG(bitstring, bitstring, bitstring): bitstring [data].

(* Constructor and reduction for the message key *)
fun msgKey(SharedKey, bitstring): bitstring
reduc forall k: SharedKey, m: bitstring;
  msgKey(k,m) = sha256((k,m)).

(* Constructor and reduction for the authorization key's fingerprint *)
fun fingerprint(SharedKey): bitstring
reduc forall k: SharedKey;
  fingerprint(k) = sha1(key2bit(k)).


(******************************************************************************)
(* Key Derivation Function (KDF)                                              *)
(******************************************************************************)
fun kdfKey(SharedKey, bitstring): SharedKey.
fun kdfIV (SharedKey, bitstring): InitV.

(* Constructor for temporary keys *)
fun SK(SharedKey, InitV): bitstring [data].

letfun kdf(k: SharedKey, mk: bitstring) =
  SK(kdfKey(k,mk), kdfIV(k,mk)).


(******************************************************************************)
(* MTProto message encryption scheme                                          *)
(******************************************************************************)
letfun encodeMsg(k: SharedKey, m: bitstring) =
  let f               = fingerprint(k) in
  let mk              = msgKey(k,m)    in
  let SK(kAES, ivAES) = kdf(k,mk)      in
  MSG(f, mk, aesEnc(m, kAES, ivAES)).


(******************************************************************************)
(* MTProto message decryption scheme                                          *)
(******************************************************************************)
letfun decodeMsg(k: SharedKey, mk: bitstring, encData: bitstring) =
  let f               = fingerprint(k)               in
  let SK(kAES, ivAES) = kdf(k,mk)                    in
  let d               = aesDec(encData, kAES, ivAES) in
  if mk = msgKey(k,d) then
    MSG(f, mk, aesDec(encData, kAES, ivAES)).


(******************************************************************************)
(* Variants of encode and decode functions to model secret chats              *)
(******************************************************************************)

(*
  In encrypted chats, each message is encrypted twice: first, with the session
  key shared only by the two communicating parties; then, with the
  authorization key of one of the clients. The latter encryption prevents an
  attacker to snoop into client-server communication, but it does not prevent
  the server to read such messages (of course). But in secret chats, the server
  should not be considered a trusted actor.

  In order to treat the server as an untrusted party, we skip the outer layer
  of encryption for secret chat messages: this allows an intruder to see the
  messages exactly as the server does. Said otherwise, it allows us to include
  the server into the attacker model.
*)
letfun encodeMsgSC(k: SharedKey, m: bitstring) =
  let f               = fingerprint(k) in
  let mk              = msgKey(k,m)    in
  MSG(f, mk, m).

(*
  Decode message for chat clients. Clients check the message key.
*)
letfun decodeMsgChatClient(k: SharedKey, mk: bitstring, m: bitstring) =
  let f = fingerprint(k) in
  if mk = msgKey(k,m) then
    MSG(f, mk, m).

(*
  Decode message for chat server. We model a sloppy (or malicious) server,
  which does not check the message key.
*)
letfun decodeMsgChatServer(k: SharedKey, mk: bitstring, m: bitstring) =
  let f = fingerprint(k) in
  MSG(f, mk, m).

