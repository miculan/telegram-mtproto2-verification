# Symbolic Models for MTProto 2.0's Cryptographic Primitives

The analysis of MTProto 2.0's encryption schemes should be done manually or in
the computational model. Symbolic modelling can provide only an
(over-)approximation for the desired properties of the cryptographic primitives.
Anyway, the code has been structured so that all the cryptographic primitives
are isolated in this folder. This makes it easy to plug a custom model for the
encryption scheme and/or for the hash functions, without touching the rest of
the code.

To use a specific model, set the `ENC` variable to the desired directory when
running `make` to (re)build the `mtproto2.pvl` library. For instance:

    make ENC=model2

Then run your queries.

Each model must be contained within a directory inside `mtproto2-encryption`
and must consist of four files, named exactly as follows:

- `mtproto2-encryption-common.pvl`: it should contain definitions that are
  common to the other files.

- `mtproto2-encryption-authorization.pvl`: it should contain the definitions
  that apply to the authorization protocol.

- `mtproto2-encryption-part-i.pvl`: it should contain a model of the encryption
  scheme for cloud chats (client-server communication), as described in [Mobile
  Protocol: Detailed
  Description](https://core.telegram.org/mtproto/description).

- `mtproto2-encryption-part-ii.pvl`: it should contain a model of the
  encryption scheme for e2e-encrypted secret chats, as described in [End-to-End
  Encryption, Secret Chats](https://core.telegram.org/api/end-to-end).

All the files must exist in the model's folder, although their content can be
organized freely (for example, one may put all the code in one file and leave
the other files empty). Overall, the files above *must* at least define
functions or macros with the following signatures:

**Hash functions/fingerprints:**

- `fpk(PubKey): HashValue`: computes the fingerprint of a server's public key.
  In Telegram, this is calculated the 64-lower bits of the SHA-1 of the public
  key. Used in the authorization protocol.

- `fps(SessionKey): HashValue`: computes the fingerprint of a session key for
  acknowledgment purposes. In Telegram, this is calculated as the 64-lower bits
  of the SHA-1 of the key. Used in secret chats and in re-keying.

- `keyID(SharedKey): HashValue`: computes what Telegram calls
  *auth_key_id* (in cloud chats) or *key_fingerprint* (in secret chats): the 64
  lower-order bits of the SHA-1 of an authorization key or of a session key,
  respectively. This is used in the encryption scheme: the value keyID(k) is
  prepended to each transmitted message as part of an external (unencryped)
  header, to identify the key used to encrypt the message.

- `hashNk(Nonce, AuthKey): HashValue`: computes what Telegram calls
  *new_nonce_hash* in the authorization protocol. This is obtained as the 128
  lower-order bits of the SHA-1 hash of the secret nonce generated by the
  client, concatenated with a byte with the value of 1, 2, or 3, and followed
  by the 64 higher-order bits of the SHA-1 of the negotiated authorization key.


**Encryption/decryption:**

- `encodeRequestDHParams(Plaintext, PubKey): Ciphertext`: encodes the message
  sent by a client in the second round of the authorization protocol. Such
  message is encrypted with the public key of the server.

- `decodeRequestDHParams(Ciphertext, PrivKey): Plaintext`: decodes the message
  sent by a client in the second round of the authorization protocol. Such
  message is encrypted with the public key of the server.

- `encodeAuthorizationMsg(Plaintext, Nonce, Nonce): Ciphertext`: in the
  authorization protocol, encodes a message encrypted with an ephemeral
  symmetric key derived from a server's nonce (ns) and a secret nonce nk
  generated by the client.

- `decodeAuthorizationMsg(Ciphertext, Nonce, Nonce): Plaintext`: in the
  authorization protocol, decodes a message encrypted with an ephemeral
  symmetric key derived from a server's nonce (ns) and a secret nonce nk
  generated by the client.

- `encodeCloudChatMsg(Plaintext, AuthKey): Message`: encodes a client-server
  message encrypted using the authorization key shared by a client and the
  server.

- `clientDecodeCloudChatMsg(Message, AuthKey): Plaintext`: allows a client to
  decode a message from the server, encrypted using the authorization key shared
  by the client and the server.

- `serverDecodeCloudChatMsg(Message): Plaintext`: allows the server to decode
  a message sent from a client, encrypted using the authorization key shared by
  the client and the server. NOTE: this function does not need the authorization
  key as a parameter, because the server retrieves the key from its own table,
  based on the keyID() associated to the message. So, in general, the code for
  this function must access AuthKeyServerTable.

- `encodeSecretChatMsg(Plaintext, SessionKey, AuthKey): Message`: encodes
  a secret chat message. In MTProto 2.0, secret chat messages are first
  end-to-end encrypted with the session key `k` shared by the clients, then an
  outer layer of encryption is added using the authorization key shared by
  a client and the server. The server acts as a forwarder: when it receives
  `{{m}_k}_kAS` from client A, it decrypts it with the authorization key `k_AS`
  to obtain `{m}_k`, it re-encrypts it with B's authorization key to obtain
  `{{m}_k}_kBS`, and sends the result to B. If the outer layer of encryption is
  omitted (i.e., the AuthKey argument is not used by this function), then the
  attacker can see the communication between clients as the server does. This
  allows us to model the server as an untrusted party in secret chats.

- `decodeSecretChatMsg(Message, SessionKey, AuthKey): Plaintext`: decodes
  a secret chat message.

