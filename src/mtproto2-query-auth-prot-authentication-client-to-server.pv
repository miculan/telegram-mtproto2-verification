(*
 * MTProto 2.0: Creating an authorization key.
 *
 * Model for the protocol used to create long-term keys shared between a client
 * and Telegram's server.
 *
 * See: https://core.telegram.org/mtproto/auth_key
 *
 * Expected time to run this script: ~3s
 *)

(* Test for reachability. TODO: move to debug queries *)
query nc, ns, nk: Nonce, p: Modulus, g, g_a, g_b: G, a, b: Z, k: AuthKey, sk: PrivKey;
  event(ClientRequestsDHParameters(nc, ns, nk))
  && event(ServerSendsAck(nc, ns, nk, p, g, a, g_b, k)).
(* ✖︎ Expected result: false *)

(* Test for reachability. TODO: move to debug queries *)
query nc, ns, nk: Nonce, p: Modulus, g, g_a, g_b: G, a, b: Z, k: AuthKey, sk: PrivKey, pID, pID': ProcessID;
  event(ClientRequestsDHParameters(nc, ns, nk))
  && event(ServerSendsAck(nc, ns, nk, p, g, a, g_b, k)).
(* ✖︎ Expected result: false *)

(*
 * There is no authentication of the client to the server. This is to be
 * expected, as the server is willing to engage communication and generate
 * authorization keys with anyone (e.g., any Telegram client app), including
 * the attacker.
 *)
query nc, ns, nk: Nonce, p: Modulus, g, g_a, g_b: G, a, b: Z, k: AuthKey, sk: PrivKey, pID, pID': ProcessID;
  event(ClientStartsSession(nc))
  && event(ServerSendsAck(nc, ns, nk, p, g, a, g_b, k))
  ==> event(ClientAcceptsAuthKey(nc, ns, nk, p, g, g_a, b, k))
  || (event(ServerGeneratesNonce(pID, ns)) && event(ServerGeneratesNonce(pID', ns)) && pID <> pID').
(* ✖︎ Expected result: false *)

(*
 * However, at the end of the authorization protocol the server knows for sure
 * that the client that has negotiated the authorization key k is the client
 * who sent the third message of the protocol.
 *)
query nc, ns, nk: Nonce, p: Modulus, g, g_a, g_b: G, a, b: Z, k: AuthKey, sk: PrivKey, pID, pID': ProcessID;
  event(ClientRequestsDHParameters(nc, ns, nk))
  && event(ServerSendsAck(nc, ns, nk, p, g, a, g_b, k))
  ==> event(ClientAcceptsAuthKey(nc, ns, nk, p, g, g_a, b, k))
  || (event(ServerGeneratesNonce(pID, ns)) && event(ServerGeneratesNonce(pID', ns)) && pID <> pID').
(* ✔︎ Expected result: true *)


(* Main *)
process
  let allowWeakDiffieHellman = false in
  (0
    | !RegisterRSAKey(Server)
    | !ServerAuth(Server)
    | !ClientAuth(Server, allowWeakDiffieHellman)
    | !GenGoodDHParameters()
  )

