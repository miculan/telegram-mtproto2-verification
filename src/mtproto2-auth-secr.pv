(*
  MTProto 2.0: Creating an authorization key.

  Model for the protocol used to create long-term keys
  shared between a client and Telegram's server.

  See: https://core.telegram.org/mtproto/auth_key

  Edit the script (uncomment the queries and processes you want to run), then
  run with:

      proverif -lib mtproto2 mtproto2-auth-secr.pv

*)

(*
  The secrecy of the message must be preserved unless any of the following happens:

  1. the private key of the server is compromised before or during the session;
  2. the secret nonce is leaked during the session;
  3. the client does not check the received Diffie-Hellman parameters;
  4. the authorization key is compromised any time after the secret message has been sent.

  This query should be run with the CompromisedNonce() event and subsequent
  out(in,nk) command in mtproto2-authorization.pv commented out (otherwise the
  query is trivially true, because that event is always reached). To verify
  that CompromisedNonce() is necessary in this query, uncomment the event and
  the out() command in the client's process and comment out CompromisedNonce()
  in this query. See also the queries below.

  Note: proving this query may take a while!

  Last benchmark: 1h36m46s.
*)
query s: PrivKey, k: SharedKey, nk: Nonce;
  attacker(secretMsg)
    ==> event(CompromisedRSAKey(s))
     || event(CompromisedNonce(nk))
     || event(ClientChecksDHParameters(false))
     || event(PostCompromisedKey(k)).
(* Result: true *)

(*
   The following query returns `false`.

   Before executing the following query, uncomment the
   CompromisedNonce() event and corresponding out(in,nk) command in
   the client's process, otherwise the query returns `true`.
*)
(* query s: PrivKey, k: SharedKey, nk: Nonce; *)
(*   attacker(secretMsg) *)
(*     ==> event(CompromisedRSAKey(s)) *)
(*      || event(ClientChecksDHParameters(false)) *)
(*      || event(PostCompromisedKey(k)). *)
(* Result: false *)

(*
   Verifying the following three queries may require >7hrs when
   all processes (good and broken) are executed in parallel. To
   speed up the process significantly, try commenting out one of
   the two server processes in the process section below.

   Before executing any of the following three queries, comment out
   CompromisedNonce() event and corresponding out(in,nk) command in
   the client's process.
*)

(* query s: PrivKey, k: SharedKey, nk: Nonce; *)
(*   attacker(secretMsg) *)
(*     ==> event(ClientChecksDHParameters(false)) *)
(*      || event(PostCompromisedKey(k)). *)
(* Result: false *)

(* query s: PrivKey, k: SharedKey, nk: Nonce; *)
(*   attacker(secretMsg) *)
(*     ==> event(CompromisedRSAKey(s)) *)
(*      || event(PostCompromisedKey(k)). *)
(* Result: false *)

(* query s: PrivKey, k: SharedKey, nk: Nonce; *)
(*   attacker(secretMsg) *)
(*     ==> event(CompromisedRSAKey(s)) *)
(*      || event(ClientChecksDHParameters(false)). *)
(* Result: false *)


(*
   Integrity: for every instance of a message received by the server, there is
   a unique instance that message sent by the client.
*)
(* axiom s: PrivKey, k: SharedKey, nk: Nonce; *)
(*   attacker(secretMsg) *)
(*     ==> event(CompromisedRSAKey(s)) *)
(*      || event(CompromisedNonce(nk)) *)
(*      || event(ClientChecksDHConfig(false)) *)
(*      || event(PostCompromisedKey(k)). *)

(*
  Integrity: if the server receives a message s encrypted with authorization
  key k, then the client has sent it. This query may take a long time.
*)
(* query s: Principal, k: SharedKey, m: bitstring, sk: PrivKey; *)
(* event(ServerReceivesSecretMessage(s,m,k)) ==> event(ClientSendsSecretMessage(s,m,k)) || event(CompromisedRSAKey(sk)). *)
(* Result: true *)


(*
  Main
*)
const S: Principal. (* Telegram server *)
const FIXED_NONCE: Nonce.

(*
  You may comment and/or uncomment processes below, but be aware that the
  execution times may easily get extremely long! Or, perhaps, they may not
  even converge.
*)
process
  new A: Principal;
  (0
  | !RSAKeys(S)
  | !(new ns: Nonce; ServerAuth(S, ns))
  (* | !ServerAuth(S, FIXED_NONCE) *)
  | !ClientAuth(A, S, GOOD_CLIENT)
  (* | !ClientAuth(A, S, BROKEN_CLIENT) *)
  )

